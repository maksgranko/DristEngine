public class InputThread
{
    private Thread _inputThread;
    private bool _running = true;
    private Action<uint, bool, uint> _onKeyEvent; // Callback: VK, isDown, controlState

    public InputThread(Action<uint, bool, uint> onKeyEvent)
    {
        _onKeyEvent = onKeyEvent;
        _inputThread = new Thread(ReadInputLoop) { IsBackground = true };
    }

    public void Start() => _inputThread.Start();

    public void Stop()
    {
        _running = false;
        FlushConsoleInputBuffer(ConsoleInputHandler._hConsoleInput); // Очистка буфера
        _inputThread.Join(100);
    }

    private void ReadInputLoop()
    {
        INPUT_RECORD[] buffer = new INPUT_RECORD[16]; // Буфер на несколько событий
        while (_running)
        {
            if (ReadConsoleInput(ConsoleInputHandler._hConsoleInput, buffer, buffer.Length, out int eventsRead))
            {
                for (int i = 0; i < eventsRead; i++)
                {
                    if (buffer[i].EventType == (ushort)EventType.KEY_EVENT)
                    {
                        KEY_EVENT_RECORD keyEvent = buffer[i].KeyEvent;
                        uint vk = keyEvent.wVirtualKeyCode;
                        bool isDown = keyEvent.bKeyDown;
                        uint controlState = keyEvent.dwControlKeyState;

                        // Проверяем transition (down/up)
                        if (_prevKeyStates.TryGetValue(vk, out bool prevDown))
                        {
                            if (isDown != prevDown)
                            {
                                _onKeyEvent(vk, isDown, controlState);
                                _prevKeyStates[vk] = isDown;

                                // Подавление: для Ctrl+C/V игнорируем или custom
                                if ((controlState & 0x0008 /* LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED */) != 0)
                                {
                                    if ((vk == 0x43 /* 'C' */ || vk == 0x56 /* 'V' */) && isDown)
                                    {
                                        Console.WriteLine("Подавлен Ctrl+C/V");
                                        continue; // Или Flush для полной очистки
                                    }
                                }

                                // Shift логика: срабатывает при каждом down клавиши, если Shift down
                                bool isShiftDown = (controlState & 0x0010 /* SHIFT_PRESSED */) != 0;
                                if (isShiftDown && isDown && vk >= 0x41 && vk <= 0x5A) // A-Z
                                {
                                    Console.WriteLine($"Shift + {(char)vk} нажато (повторно при hold)");
                                }
                                else if (!isShiftDown && prevDown && vk == 0x10 /* VK_SHIFT */)
                                {
                                    Console.WriteLine("Shift отпущен - сбрасываем флаги");
                                    // Здесь сбросьте любые "зависшие" состояния, если нужно (очистите _prevKeyStates для букв?)
                                }
                            }
                        }
                        else
                        {
                            _prevKeyStates[vk] = isDown; // Init
                        }
                    }
                }
            }
            else
            {
                Thread.Sleep(1); // Non-blocking poll
            }
        }
    }

    [StructLayout(LayoutKind.Explicit)]
    private struct INPUT_RECORD
    {
        [FieldOffset(0)] public ushort EventType;
        [FieldOffset(4)] public KEY_EVENT_RECORD KeyEvent;
        // Другие поля для MOUSE/ etc., но нам не нужны
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct KEY_EVENT_RECORD
    {
        public ushort bKeyDown;
        public ushort wRepeatCount;
        public ushort wVirtualKeyCode;
        public ushort wVirtualScanCode;
        public char UnicodeChar;
        public uint dwControlKeyState;
    }

    private enum EventType : ushort
    {
        KEY_EVENT = 0x0001,
        // ...
    }
}

// В Main:
class Program
{
    static void Main()
    {
        ConsoleInputHandler.SetupConsole();

        var inputThread = new InputThread((vk, isDown, controlState) =>
        {
            // Ваша WinAPI-логика здесь
            Console.WriteLine($"VK: {vk}, Down: {isDown}, CtrlState: {controlState:X}");
        });
        inputThread.Start();

        Console.WriteLine("Нажмите Ctrl+C/V или Shift+A для теста. ESC для выхода.");
        while (Console.ReadKey(true).Key != ConsoleKey.Escape) { } // Ждём в main

        inputThread.Stop();
    }
}














using System;
using System.Runtime.InteropServices;
using System.Threading;
using System.Collections.Generic;

public class ConsoleInputHandler
{
    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool SetConsoleCtrlHandler(ConsoleCtrlDelegate handler, bool add);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool GetConsoleMode(IntPtr hConsoleOutput, out int lpMode);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool SetConsoleMode(IntPtr hConsoleOutput, int dwMode);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool ReadConsoleInput(IntPtr hConsoleInput, [Out] INPUT_RECORD[] lpBuffer, int nLength, out int lpNumberOfEventsRead);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool FlushConsoleInputBuffer(IntPtr hConsoleInput);

    [DllImport("kernel32.dll")]
    private static extern IntPtr GetStdHandle(int nStdHandle);

    private const int STD_INPUT_HANDLE = -10;
    private const int ENABLE_PROCESSED_INPUT = 0x0001;
    private const int ENABLE_LINE_INPUT = 0x0002;
    private const int ENABLE_ECHO_INPUT = 0x0004;
    private const int ENABLE_WINDOW_INPUT = 0x0008;
    private const int ENABLE_MOUSE_INPUT = 0x0010;
    private const int ENABLE_EXTENDED_FLAGS = 0x0080; // Для Ctrl как ввода
    private const int ENABLE_INSERT_MODE = 0x0020;
    private const int CTRL_C_EVENT = 0;

    public delegate bool ConsoleCtrlDelegate(uint ctrlType);

    private static IntPtr _hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
    private static Dictionary<uint, bool> _prevKeyStates = new(); // Отслеживание состояний по VK

    public static void SetupConsole()
    {
        // Отключаем Ctrl+C как сигнал, делаем его вводом
        Console.TreatControlCAsInput = true; // .NET wrapper для SetConsoleMode с ENABLE_EXTENDED_FLAGS
        SetConsoleCtrlHandler(null, false); // Удаляем default handler

        // Режим: processed input, no line/echo, extended flags (Ctrl как клавиши), mouse если нужно
        if (!GetConsoleMode(_hConsoleInput, out int mode))
            throw new Exception("GetConsoleMode failed");
        mode |= ENABLE_PROCESSED_INPUT | ENABLE_EXTENDED_FLAGS | ENABLE_WINDOW_INPUT;
        mode &= ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT); // Non-blocking, no auto-line
        if (!SetConsoleMode(_hConsoleInput, mode))
            throw new Exception("SetConsoleMode failed");

        // Отключаем StickyKeys (добавьте из предыдущего примера)
        StickyKeysDisabler.Disable(); // Если нужно
    }

    // Custom handler для Ctrl+C, если всё же нужен (опционально)
    private static bool CtrlHandler(uint ctrlType)
    {
        if (ctrlType == CTRL_C_EVENT)
        {
            // Игнорируем или обрабатываем custom
            return true; // Подавляем default
        }
        return false;
    }
}
















using System;
using System.Runtime.InteropServices;

public class StickyKeysDisabler
{
    [DllImport("user32.dll", SetLastError = true)]
    private static extern bool SystemParametersInfo(uint uiAction, uint uiParam, ref STICKYKEYS pvParam, uint fWinIni);

    private const uint SPI_GETSTICKYKEYS = 0x003A;
    private const uint SPI_SETSTICKYKEYS = 0x003B;
    private const uint SKF_STICKYKEYSON = 0x00000001;

    [StructLayout(LayoutKind.Sequential)]
    public struct STICKYKEYS
    {
        public uint cbSize;
        public uint dwFlags;
    }

    public static void Disable()
    {
        STICKYKEYS sk = new STICKYKEYS();
        sk.cbSize = (uint)Marshal.SizeOf(sk);
        SystemParametersInfo(SPI_GETSTICKYKEYS, sk.cbSize, ref sk, 0);
        sk.dwFlags &= ~SKF_STICKYKEYSON; // Выключаем
        SystemParametersInfo(SPI_SETSTICKYKEYS, sk.cbSize, ref sk, 0);
        Console.WriteLine("StickyKeys отключены");
    }
}

// В Main: StickyKeysDisabler.Disable();